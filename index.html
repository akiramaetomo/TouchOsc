<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="viewport" content="width=device-width, initial-scale=1.0">
  <title>Touch Oscillator</title>
  <style>
    body {
      background-color: #2c0a17; /* ワインレッド */
      color: #f0e5d8; /* オフホワイト */
      font-family: Arial, sans-serif;
      font-size: 18px; /* 全体の文字サイズをスマホに合わせて大きく */
    }

    #synthArea {
      width: 100%;
      height: 400px;
      border: 2px solid #f0e5d8; /* オフホワイト */
      position: relative;
      touch-action: none;
      background-color: #3c0e1c; /* より濃いワインレッド */
    }

    .pointer {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid rgba(80, 0, 0, 0.8); /* 太めの暗い枠線 */
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); /* ゴールド系のぼかし効果 */
    }

    .pointer1 {
      background-color: #d4af37; /* ゴールド */
    }

    .pointer2 {
      background-color: #ffd700; /* より鮮やかなゴールド */
    }

    .debug-box {
      margin: 10px;
    }

    input, select {
      background-color: #3c0e1c;
      color: #f0e5d8;
      border: 1px solid #f0e5d8;
      font-size: 18px; /* テキストボックスの文字サイズをスマホ向けに大きく */
      padding: 5px; /* 余白を追加してタップしやすく */
    }

    h1 {
      color: #f0e5d8;
      font-size: 24px; /* タイトル文字を大きく */
    }

    label {
      display: inline-block;
      width: 100px;
    }

    .envelope-controls {
      margin: 10px 0;
    }

    .slider {
      width: 100%;
    }
  </style>
</head>
<body>

<h1>Touch Oscillator</h1>

<div class="waveform-selector">
  <label for="waveform">Waveform:</label>
  <select id="waveform">
    <option value="sine">Sine</option>
    <option value="sawtooth">Sawtooth</option>
    <option value="square">Square</option>
    <option value="triangle">Triangle</option>
  </select>
</div>

<div class="envelope-controls">
  <label for="attackSlider">Attack:</label>
  <input type="range" id="attackSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
  <br>
  <label for="releaseSlider">Release:</label>
  <input type="range" id="releaseSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
</div>

<div id="synthArea"></div>

<div class="debug-box">
  <label>Tap 1 X,Y: <input type="text" id="tap1" readonly></label><br>
  <label>Tap 2 X,Y: <input type="text" id="tap2" readonly></label><br>
  <label>OSC1 Freq, Vol: <input type="text" id="osc1" readonly></label><br>
  <label>OSC2 Freq, Vol: <input type="text" id="osc2" readonly></label>
</div>

<script>
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillators = {};
  const gainNodes = {};
  const pointers = {};
  const baseVolume = 0.5;

  const synthArea = document.getElementById('synthArea');
  const waveformSelect = document.getElementById('waveform');
  const tap1Display = document.getElementById('tap1');
  const tap2Display = document.getElementById('tap2');
  const osc1Display = document.getElementById('osc1');
  const osc2Display = document.getElementById('osc2');

  const attackSlider = document.getElementById('attackSlider');
  const releaseSlider = document.getElementById('releaseSlider');

  const synthAreaRect = synthArea.getBoundingClientRect();

  function createPointer(id, className) {
    const pointer = document.createElement('div');
    pointer.classList.add('pointer', className);
    pointer.id = id;
    synthArea.appendChild(pointer);
    return pointer;
  }

  function movePointer(pointer, x, y) {
    pointer.style.left = `${x - 20}px`;
    pointer.style.top = `${y - synthAreaRect.top - 20}px`;
  }
  function startOscillator(fingerId, frequency, volume) {
    // すでにオシレータが存在する場合は強制的に停止してから新たに発音
    if (oscillators[fingerId]) {
      stopOscillator(fingerId, true); // 強制停止
    }
  
  // 少し遅延を入れて確実に停止後、新しいオシレータをトリガ
  setTimeout(() => {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    const attackTime = parseFloat(attackSlider.value);

    oscillator.type = waveformSelect.value;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

    gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // 初期ゲインをゼロに設定
    gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + attackTime); // アタックの反映

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();

    oscillators[fingerId] = oscillator;
    gainNodes[fingerId] = gainNode;
  }, 0); // 停止が完了した直後に新しいオシレータを開始
  }
  
  

  function stopOscillator(fingerId, immediate = false) {
    if (oscillators[fingerId]) {
      const releaseTime = parseFloat(releaseSlider.value);
      const currentGain = gainNodes[fingerId].gain.value;
      gainNodes[fingerId].gain.cancelScheduledValues(audioCtx.currentTime);
  
      if (immediate) {
        // 強制停止: リリースを無視して即時停止
        gainNodes[fingerId].gain.setValueAtTime(0, audioCtx.currentTime);
        oscillators[fingerId].stop(audioCtx.currentTime);
      } else {
        // 通常のリリース
        gainNodes[fingerId].gain.setValueAtTime(currentGain, audioCtx.currentTime);
        gainNodes[fingerId].gain.linearRampToValueAtTime(0, audioCtx.currentTime + releaseTime);
        oscillators[fingerId].stop(audioCtx.currentTime + releaseTime);
      }
      
      setTimeout(() => {
        oscillators[fingerId].disconnect();
        gainNodes[fingerId].disconnect();
        delete oscillators[fingerId];
        delete gainNodes[fingerId];
      }, immediate ? 0 : releaseTime * 1000);
    }
  }
  

  function calculateFrequency(yPosition) {
    const height = synthArea.clientHeight;
    const logMinFreq = Math.log10(220); // 220Hz
    const logMaxFreq = Math.log10(880); // 880Hz
    const relativeY = height - (yPosition - synthAreaRect.top); // Corrected to account for screen offset
    const logFrequency = logMinFreq + (relativeY / height) * (logMaxFreq - logMinFreq);
    return Math.pow(10, logFrequency);
  }

  function calculateVolume(xPosition) {
    const width = synthArea.clientWidth;
    const dB = -24 + (xPosition / width) * 24; // -24dB to 0dB
    return baseVolume * Math.pow(10, dB / 20); // Convert dB to linear scale
  }

  synthArea.addEventListener('touchstart', (event) => {
    for (let i = 0; i < event.touches.length && i < 2; i++) {
      const touch = event.touches[i];
      const frequency = calculateFrequency(touch.clientY);
      const volume = calculateVolume(touch.clientX);
      const fingerId = touch.identifier;

      // Display pointer
      if (!pointers[fingerId]) {
        pointers[fingerId] = createPointer(`pointer${fingerId}`, i === 0 ? 'pointer1' : 'pointer2');
      }
      movePointer(pointers[fingerId], touch.clientX, touch.clientY);

      startOscillator(fingerId, frequency, volume);

      const freqVolDisplay = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
      if (i === 0) {
        tap1Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc1Display.value = freqVolDisplay;
      } else {
        tap2Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc2Display.value = freqVolDisplay;
      }
    }
  });

  synthArea.addEventListener('touchend', (event) => {
    for (let i = 0; i < event.changedTouches.length; i++) {
      const touch = event.changedTouches[i];
      const fingerId = touch.identifier;
      stopOscillator(fingerId);

      // Remove pointer
      const pointer = pointers[fingerId];
      if (pointer) {
        synthArea.removeChild(pointer);
        delete pointers[fingerId];
      }
    }
  });

  synthArea.addEventListener('touchmove', (event) => {
    for (let i = 0; i < event.touches.length && i < 2; i++) {
      const touch = event.touches[i];
      const frequency = calculateFrequency(touch.clientY);
      const volume = calculateVolume(touch.clientX);
      const fingerId = touch.identifier;

      if (oscillators[fingerId]) {
        oscillators[fingerId].frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNodes[fingerId].gain.setValueAtTime(volume, audioCtx.currentTime);
      }

      // Move pointer
      movePointer(pointers[fingerId], touch.clientX, touch.clientY);

      const freqVolDisplay = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
      if (i === 0) {
        tap1Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc1Display.value = freqVolDisplay;
      } else {
        tap2Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc2Display.value = freqVolDisplay;
      }
    }
  });

  // Mouse event support for desktop
  let isMouseDown = false;

  synthArea.addEventListener('mousedown', (event) => {
    isMouseDown = true;
    const frequency = calculateFrequency(event.clientY);
    const volume = calculateVolume(event.clientX);

    // Create a single pointer for mouse
    if (!pointers['mouse']) {
      pointers['mouse'] = createPointer('pointerMouse', 'pointer1');
    }
    movePointer(pointers['mouse'], event.clientX, event.clientY);

    startOscillator('mouse', frequency, volume);
    tap1Display.value = `${event.clientX}, ${event.clientY}`;
    osc1Display.value = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
  });

  synthArea.addEventListener('mouseup', () => {
    isMouseDown = false;
    stopOscillator('mouse');

    // Remove pointer
    if (pointers['mouse']) {
      synthArea.removeChild(pointers['mouse']);
      delete pointers['mouse'];
    }
  });

  synthArea.addEventListener('mousemove', (event) => {
    if (isMouseDown) {
      const frequency = calculateFrequency(event.clientY);
      const volume = calculateVolume(event.clientX);

      if (oscillators['mouse']) {
        oscillators['mouse'].frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNodes['mouse'].gain.setValueAtTime(volume, audioCtx.currentTime);
      }

      // Move pointer
      movePointer(pointers['mouse'], event.clientX, event.clientY);

      tap1Display.value = `${event.clientX}, ${event.clientY}`;
      osc1Display.value = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
    }
  });
</script>

</body>
</html>
