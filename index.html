<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.75">

  <title>Touch Oscillator</title>
  <style>
    body {
      background-color: #2c0a17; /* ワインレッド */
      color: #f0e5d8; /* オフホワイト */
      font-family: Arial, sans-serif;
      font-size: 18px; /* 全体の文字サイズをスマホに合わせて大きく */
    }

    #synthArea {
      width: 100%;
      height: 600px;
      border: 3px solid #f0e5d8; /* オフホワイト */
      position: relative;
      touch-action: none;
      background-color: #3c0e1c; /* より濃いワインレッド */
    }

    .pointer {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 0px solid rgba(80, 0, 0, 0.8); /* 太めの暗い枠線 */
      box-shadow: 0 0 50px rgba(255, 215, 0, 0.7); /* ゴールド系のぼかし効果 */
    }

    .pointer1 {
      background-color: #d4af37; /* ゴールド */
    }

    .pointer2 {
      background-color: #ffd700; /* より鮮やかなゴールド */
    }

    .debug-box {
      margin: 20px;
    }

    .debug-box label {
        display: inline-block;
        margin-right: 20px;
        width: 150px; /* ラベルの幅を調整 */
        white-space: nowrap; /* テキストを折り返さないようにする */
      }
  
      .debug-box input[type="text"] {
        display: inline-block;
        width: 300px; /* ラベルの幅を調整 */

      }


    input, select {
      background-color: #3c0e1c;
      color: #f0e5d8;
      border: 1px solid #f0e5d8;
      font-size: 18px; /* テキストボックスの文字サイズをスマホ向けに大きく */
      padding: 5px; /* 余白を追加してタップしやすく */
    }

    h1 {
      color: #f0e5d8;
      font-size: 24px; /* タイトル文字を大きく */
    }

    label {
      display: inline-block;
      width: 100px;
    }

    .envelope-controls {
        display: flex;
        align-items: center;
        gap: 10px; /* ラベルとスライダーの間のスペース */
        margin: 0px 0;
        width: 100%; /* タッチ領域の幅に合わせる */
      }
      
      .slider {
        flex-grow: 1; /* スライダーを残りのスペースに広げる */
      }
  </style>
</head>
<body>

<h1>Touch Oscillator</h1>

<div class="waveform-selector">
  <label for="waveform">Waveform:</label>
  <select id="waveform">
    <option value="sine">Sine</option>
    <option value="sawtooth">Sawtooth</option>
    <option value="square">Square</option>
    <option value="triangle">Triangle</option>
  </select>
</div>

<div class="envelope-controls">
  <label for="attackSlider">Attack:</label>
  <input type="range" id="attackSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
  <label for="releaseSlider">Release:</label>
  <input type="range" id="releaseSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
</div>
<div id="synthArea"></div>

<div class="debug-box">
  <label>Tap 1 X,Y:</label><input type="text" id="tap1" readonly><br>
  <label>Tap 2 X,Y:</label><input type="text" id="tap2" readonly><br>
  <label>OSC1 Freq,Vol:</label><input type="text" id="osc1" readonly><br>
  <label>OSC2 Freq,Vol:</label><input type="text" id="osc2" readonly><br>
  <label>OSC1 Trig,State:</label><input type="text" id="osc1state" readonly><br>
  <label>OSC2 Trig,State:</label><input type="text" id="osc2state" readonly><br>
   <!-- 新しいデバッグ表示追加 -->
   <label>Attack Time:</label><input type="text" id="attackDisplay" readonly><br>
   <label>Release Time:</label><input type="text" id="releaseDisplay" readonly>
</div>

<script>
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillators = {};
  const gainNodes = {};
  const pointers = {};
  const onFlags = {}; //by mae
  const baseVolume = 0.5;

  const synthArea = document.getElementById('synthArea');
  const waveformSelect = document.getElementById('waveform');
  const tap1Display = document.getElementById('tap1');
  const tap2Display = document.getElementById('tap2');
  const osc1Display = document.getElementById('osc1');
  const osc2Display = document.getElementById('osc2');
  const osc1stDisplay = document.getElementById('osc1state');
  const osc2stDisplay = document.getElementById('osc2state');

  const attackSlider = document.getElementById('attackSlider');
  const releaseSlider = document.getElementById('releaseSlider');

  const synthAreaRect = synthArea.getBoundingClientRect();

  function createPointer(id, className) {
    const pointer = document.createElement('div');
    pointer.classList.add('pointer', className);
    pointer.id = id;
    synthArea.appendChild(pointer);
    return pointer;
  }

  function movePointer(pointer, x, y) {
    pointer.style.left = `${x - 20}px`;
    pointer.style.top = `${y - synthAreaRect.top - 20}px`;
  }


  function startOscillator(fingerId, frequency, volume) {
    // すでにオシレータが存在する場合は強制的に停止してから新たに発音
    if (oscillators[fingerId]) {
      stopOscillator(fingerId, true); // 強制停止

    }else{
        osc1stDisplay.value = "OSC " + fingerId + " START"; // for debug   
    }
  
    // 新しいオシレータを少し遅らせて開始
    setTimeout(() => {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      const attackTime = parseFloat(attackSlider.value);
      
      attackDisplay.value =  audioCtx.currentTime; //for debug
      releaseDisplay.value =  audioCtx.currentTime+attackTime; //for debug

      oscillator.type = waveformSelect.value;
      oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
  
      gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // 初期ゲインをゼロに設定
      gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + attackTime); // アタックの反映
  
      // オシレータとゲインノードを指IDごとに配列に格納
      oscillators[fingerId] = oscillator;
      gainNodes[fingerId] = gainNode;
  
      // オシレータとゲインノードの接続
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
  
      // オシレータを開始
      oscillator.start();
    }, 10); // 強制停止後に少し遅らせてオシレータをトリガする
  }
  
  function stopOscillator(fingerId, immediate = false) {
    if (oscillators[fingerId]) {
      const releaseTime = parseFloat(releaseSlider.value);
      const currentGain = gainNodes[fingerId].gain.value;
      const currentOscillator = oscillators[fingerId];  // 現在のオシレータを保存
      gainNodes[fingerId].gain.cancelScheduledValues(audioCtx.currentTime);
  
      if (immediate) {
        osc1stDisplay.value = "OSC " + fingerId + " force_STOP   " + "immediate:" + immediate ; // for debug   

        // 強制停止: リリースを無視して即時停止
        gainNodes[fingerId].gain.setValueAtTime(0, audioCtx.currentTime);
        currentOscillator.stop(audioCtx.currentTime);

        // オシレータのクリーンアップ
        setTimeout(() => {
          // 現在のオシレータが同じか確認
          if (oscillators[fingerId] === currentOscillator) {
            oscillators[fingerId].disconnect();
            gainNodes[fingerId].disconnect();
            delete oscillators[fingerId];
            delete gainNodes[fingerId];
          }
        }, 0);
      } else {
        osc1stDisplay.value = "OSC " + fingerId + " normal RELEASE  " + "immediate:" + immediate ; // for debug   

        // 通常のリリース
        gainNodes[fingerId].gain.setValueAtTime(currentGain, audioCtx.currentTime);
        gainNodes[fingerId].gain.linearRampToValueAtTime(0, audioCtx.currentTime + releaseTime);
        currentOscillator.stop(audioCtx.currentTime + releaseTime);

        // リリース完了後にクリーンアップ
        setTimeout(() => {
          // 現在のオシレータが同じか確認
          if (oscillators[fingerId] === currentOscillator) {
            osc1stDisplay.value = "OSC " + fingerId + " release end & clean up"; // for debug   
            oscillators[fingerId].disconnect();
            gainNodes[fingerId].disconnect();
            delete oscillators[fingerId];
            delete gainNodes[fingerId];
          }
        }, releaseTime * 1000);
      }
    }
}


  function calculateFrequency(yPosition) {
    const height = synthArea.clientHeight;
    const logMinFreq = Math.log10(27.5); // 220Hz 27.5,55,110,220,440,880,1760,3520,7040
    const logMaxFreq = Math.log10(7040); // 880Hz
    const relativeY = height - (yPosition - synthAreaRect.top); // Corrected to account for screen offset
    const logFrequency = logMinFreq + (relativeY / height) * (logMaxFreq - logMinFreq);
    return Math.pow(10, logFrequency);
  }

  function calculateVolume(xPosition) {
    const width = synthArea.clientWidth;
    const dB = -24 + (xPosition / width) * 24; // -24dB to 0dB
    return baseVolume * Math.pow(10, dB / 20); // Convert dB to linear scale
  }

  //イベントリスナー***********************************************************************
  synthArea.addEventListener('touchstart', (event) => {
    event.preventDefault();  // デフォルトのマウスイベントやスクロールを抑制

    // AudioContextを一度だけ再開 for debug
//    if (!isAudioContextResumed && audioCtx.state === 'suspended') {
//        await audioCtx.resume();
//        isAudioContextResumed = true;
//    }


    for (let i = 0; i < event.touches.length && i < 2; i++) {
    //    const touch = event.touches[i];//これは不適切とのこと。以下にした。
        const touch = event.changedTouches [i];
        const frequency = calculateFrequency(touch.clientY);
      const volume = calculateVolume(touch.clientX);
      const fingerId = touch.identifier;

      // Display pointer
      if (!pointers[fingerId]) {
        pointers[fingerId] = createPointer(`pointer${fingerId}`, i === 0 ? 'pointer1' : 'pointer2');
      }
      movePointer(pointers[fingerId], touch.clientX, touch.clientY);

      startOscillator(fingerId, frequency, volume);

      const freqVolDisplay = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
      if (i === 0) {
        tap1Display.value = `${touch.clientX.toFixed(2)}, ${touch.clientY.toFixed(2)}`;
        osc1Display.value = freqVolDisplay;
      } else {
        tap2Display.value = `${touch.clientX.toFixed(2)}, ${touch.clientY.toFixed(2)}`;
        osc2Display.value = freqVolDisplay;
      }
    }
  });

  synthArea.addEventListener('touchend', (event) => {
    event.preventDefault();  // デフォルトのマウスイベントやスクロールを抑制

    for (let i = 0; i < event.changedTouches.length; i++) {
      const touch = event.changedTouches[i];
      const fingerId = touch.identifier;
      stopOscillator(fingerId);

      // Remove pointer
      const pointer = pointers[fingerId];
      if (pointer) {
        synthArea.removeChild(pointer);
        delete pointers[fingerId];
      }
    }
  });

  synthArea.addEventListener('touchmove', (event) => {
    event.preventDefault();  // デフォルトのマウスイベントやスクロールを抑制

    for (let i = 0; i < event.touches.length && i < 2; i++) {
      const touch = event.touches[i];
      const frequency = calculateFrequency(touch.clientY);
      const volume = calculateVolume(touch.clientX);
      const fingerId = touch.identifier;

      if (oscillators[fingerId]) {
        oscillators[fingerId].frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNodes[fingerId].gain.setValueAtTime(volume, audioCtx.currentTime);
      }

      // Move pointer
      movePointer(pointers[fingerId], touch.clientX, touch.clientY);

      const freqVolDisplay = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
      if (i === 0) {
        tap1Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc1Display.value = freqVolDisplay;
      } else {
        tap2Display.value = `${touch.clientX}, ${touch.clientY}`;
        osc2Display.value = freqVolDisplay;
      }
    }
  });

  // Mouse event support for desktop
  let isMouseDown = false;

  synthArea.addEventListener('mousedown', (event) => {
    isMouseDown = true;
    const frequency = calculateFrequency(event.clientY);
    const volume = calculateVolume(event.clientX);

    // Create a single pointer for mouse
    if (!pointers['mouse']) {
      pointers['mouse'] = createPointer('pointerMouse', 'pointer1');
    }
    movePointer(pointers['mouse'], event.clientX, event.clientY);

    startOscillator('mouse', frequency, volume);
    tap1Display.value = `${event.clientX}, ${event.clientY}`;
    osc1Display.value = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
  });

  synthArea.addEventListener('mouseup', () => {
    isMouseDown = false;
    stopOscillator('mouse');

    // Remove pointer
    if (pointers['mouse']) {
      synthArea.removeChild(pointers['mouse']);
      delete pointers['mouse'];
    }
  });

  synthArea.addEventListener('mousemove', (event) => {
    if (isMouseDown) {
      const frequency = calculateFrequency(event.clientY);
      const volume = calculateVolume(event.clientX);

      if (oscillators['mouse']) {
        oscillators['mouse'].frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNodes['mouse'].gain.setValueAtTime(volume, audioCtx.currentTime);
      }

      // Move pointer
      movePointer(pointers['mouse'], event.clientX, event.clientY);

      tap1Display.value = `${event.clientX}, ${event.clientY}`;
      osc1Display.value = `${frequency.toFixed(4)} Hz, ${(volume * 100).toFixed(4)}%`;
    }
  });

  const attackDisplay = document.getElementById('attackDisplay');
  const releaseDisplay = document.getElementById('releaseDisplay');
  
  // スライダーの値をリアルタイムで表示するためのリスナー
  attackSlider.addEventListener('input', () => {
    attackDisplay.value = attackSlider.value;
  });
  
  releaseSlider.addEventListener('input', () => {
 //   releaseDisplay.value = releaseSlider.value;
  });
  
  // ページロード時に初期値を表示
  attackDisplay.value = attackSlider.value;
  releaseDisplay.value = releaseSlider.value;




</script>

</body>
</html>
