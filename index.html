<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="viewport" content="width=device-width, initial-scale=1.0">
  <title>Touch Oscillator</title>
  <style>
    body {
      background-color: #2c0a17; /* ワインレッド */
      color: #f0e5d8; /* オフホワイト */
      font-family: Arial, sans-serif;
      font-size: 18px; /* 全体の文字サイズをスマホに合わせて大きく */
    }

    #synthArea {
      width: 100%;
      height: 400px;
      border: 2px solid #f0e5d8; /* オフホワイト */
      position: relative;
      touch-action: none;
      background-color: #3c0e1c; /* より濃いワインレッド */
    }

    .pointer {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid rgba(80, 0, 0, 0.8); /* 太めの暗い枠線 */
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); /* ゴールド系のぼかし効果 */
    }

    .pointer1 {
      background-color: #d4af37; /* ゴールド */
    }

    .pointer2 {
      background-color: #ffd700; /* より鮮やかなゴールド */
    }

    .debug-box {
      margin: 10px;
    }

    input, select {
      background-color: #3c0e1c;
      color: #f0e5d8;
      border: 1px solid #f0e5d8;
      font-size: 18px; /* テキストボックスの文字サイズをスマホ向けに大きく */
      padding: 5px; /* 余白を追加してタップしやすく */
    }

    h1 {
      color: #f0e5d8;
      font-size: 24px; /* タイトル文字を大きく */
    }

    label {
      display: inline-block;
      width: 100px;
    }

    .envelope-controls {
      margin: 10px 0;
    }

    .slider {
      width: 100%;
    }
  </style>
</head>
<body>

<h1>Touch Oscillator</h1>

<div class="waveform-selector">
  <label for="waveform">Waveform:</label>
  <select id="waveform">
    <option value="sine">Sine</option>
    <option value="sawtooth">Sawtooth</option>
    <option value="square">Square</option>
    <option value="triangle">Triangle</option>
  </select>
</div>

<div class="envelope-controls">
  <label for="attackSlider">Attack:</label>
  <input type="range" id="attackSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
  <br>
  <label for="releaseSlider">Release:</label>
  <input type="range" id="releaseSlider" class="slider" min="0.01" max="2" step="0.01" value="0.5">
</div>

<div id="synthArea"></div>

<div class="debug-box">
  <label>Tap 1 X,Y: <input type="text" id="tap1" readonly></label><br>
  <label>Tap 2 X,Y: <input type="text" id="tap2" readonly></label><br>
  <label>OSC1 Freq, Vol: <input type="text" id="osc1" readonly></label><br>
  <label>OSC2 Freq, Vol: <input type="text" id="osc2" readonly></label>
</div>

<script>
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const oscillators = {};
  const gainNodes = {};
  const pointers = {};
  const baseVolume = 0.5;

  const synthArea = document.getElementById('synthArea');
  const waveformSelect = document.getElementById('waveform');
  const tap1Display = document.getElementById('tap1');
  const tap2Display = document.getElementById('tap2');
  const osc1Display = document.getElementById('osc1');
  const osc2Display = document.getElementById('osc2');

  const attackSlider = document.getElementById('attackSlider');
  const releaseSlider = document.getElementById('releaseSlider');

  const synthAreaRect = synthArea.getBoundingClientRect();

  function createPointer(id, className) {
    const pointer = document.createElement('div');
    pointer.classList.add('pointer', className);
    pointer.id = id;
    synthArea.appendChild(pointer);
    return pointer;
  }

  function movePointer(pointer, x, y) {
    pointer.style.left = `${x - 20}px`;
    pointer.style.top = `${y - synthAreaRect.top - 20}px`;
  }
  function startOscillator(fingerId, frequency, volume) {
    // すでにオシレータが存在する場合は強制的に停止してから新たに発音
    if (oscillators[fingerId]) {
      stopOscillator(fingerId, true); // 強制停止
    }
  
  // 少し遅延を入れて確実に停止後、新しいオシレータをトリガ
  setTimeout(() => {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    const attackTime = parseFloat(attackSlider.value);

    oscillator.type = waveformSelect.value;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

    gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // 初期ゲインをゼロに設定
    gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + attackTime); // アタックの反映

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();

    oscillators[fingerId] = oscillator;
    gainNodes[fingerId] = gainNode;
  }, 0); // 停止が完了した直後に新しいオシレータを開始
  }
  
  

  function stopOscillator(fingerId, immediate = false) {
    if (oscillators[fingerId]) {
      const releaseTime = parseFloat(releaseSlider.value);
      const currentGain = gainNodes[fingerId].gain.value;
      gainNodes[fingerId].gain.cancelScheduledValues(audioCtx.currentTime);
  
      if (immediate) {
        // 強制停止: リリースを無視して即時停止
        gainNodes[fingerId].gain.setValueAtTime(0, audioCtx.currentTime);
        oscillators[fingerId].stop(audioCtx.currentTime);
      } else {
        // 通常のリリース
        gainNodes[fingerId].gain.setValueAtTime(currentGain, audioCtx.currentTime);
        gainNodes[fingerId].gain.linearRampToValueAtTime(0, audioCtx.currentTime + releaseTime);
        oscillators[fingerId].stop(audioCtx.currentTime + releaseTime);
      }
      
      setTimeout(() => {
        oscillators[fingerId].disconnect();
        gainNodes[fingerId].disconnect();
        delete oscillators[fingerId];
        delete gainNodes[fingerId];
      }, immediate ? 0 : releaseTime * 1000);
    }
  }
  

  function calculateFrequency(yPosition) {
    const height = synthArea.clientHeight;
    const logMinFreq = Math.log10(220); // 220Hz
    const logMaxFreq = Math.log10(880); // 880Hz
    const relativeY = height - (yPosition - synthAreaRect.top); // Corrected to account for screen offset
    const logFrequency = logMinFreq + (relativeY / height) * (logMaxFreq - logMinFreq);
